// Test: Nested generic types (Option<Box<int>>)

Box<T> :: struct {
    value T
}

Option<T> :: variant {
    Some { value T }
    None
}

fn main {
    Option<Box<int>> nested = Option<Box<int>>.Some {
        value: Box<int> { value: 42 }
    }

    Option<Box<int>> empty = Option<Box<int>>.None

    int result1 = match nested using Option<Box<int>> {
        Some { value: box } -> box.value,
        None -> 0
    }

    int result2 = match empty using Option<Box<int>> {
        Some { value: box } -> box.value,
        None -> 99
    }

    if result1 == 42 && result2 == 99 {
        print("nested generics test passed")
    } else {
        print("FAIL: nested values incorrect")
    }
}
