// Generics tests

Box<T> :: struct {
    value T
}

Pair<A, B> :: struct {
    first A
    second B
}

Container<T> :: struct {
    items T[]
}

Container<T> :: add(self, T item) {
    self.items.push(item)
}

Container<T> :: count(self) int {
    return self.items.len()
}

Maybe<T> :: variant {
    Just { value T }
    Nothing
}

fn main {
    t := new_test()

    // Generic struct with int
    Box<int> int_box = Box<int> { value: 42 }
    t.assert_eq_int(42, int_box.value)

    // Generic struct with str
    Box<str> str_box = Box<str> { value: "hello" }
    t.assert_eq_str("hello", str_box.value)

    // Multiple type parameters
    Pair<int, str> p = Pair<int, str> { first: 1, second: "one" }
    t.assert_eq_int(1, p.first)
    t.assert_eq_str("one", p.second)

    // Generic with array field
    Container<int> c = Container<int> { items: [1, 2, 3] }
    t.assert_eq_int(3, c.count())

    // Generic method
    c.add(4)
    t.assert_eq_int(4, c.count())

    // Generic variant
    Maybe<int> just_val = Maybe<int>.Just { value: 100 }
    Maybe<int> nothing = Maybe<int>.Nothing

    int just_result = match just_val using Maybe<int> {
        Just { value: v } -> v,
        Nothing -> 0
    }
    t.assert_eq_int(100, just_result)

    int nothing_result = match nothing using Maybe<int> {
        Just { value: v } -> v,
        Nothing -> 0
    }
    t.assert_eq_int(0, nothing_result)

    // Reusing same generic type
    Box<int> box1 = Box<int> { value: 10 }
    Box<int> box2 = Box<int> { value: 20 }
    t.assert_eq_int(10, box1.value)
    t.assert_eq_int(20, box2.value)

    t.summary()
}
