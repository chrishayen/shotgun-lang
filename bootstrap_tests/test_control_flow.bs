// Control flow tests

fn absolute(int x) int {
    if x < 0 {
        return 0 - x
    }
    return x
}

fn classify(int x) str {
    if x < 0 {
        return "negative"
    } else if x == 0 {
        return "zero"
    } else {
        return "positive"
    }
}

fn grade(int score) str {
    return match score {
        100 -> "perfect",
        90 -> "A",
        80 -> "B",
        70 -> "C",
        _ -> "other"
    }
}

fn main {
    t := new_test()

    // Basic if
    t.assert_eq_int(5, absolute(5))
    t.assert_eq_int(5, absolute(0 - 5))
    t.assert_eq_int(0, absolute(0))

    // If-else-if chain
    t.assert_eq_str("negative", classify(0 - 10))
    t.assert_eq_str("zero", classify(0))
    t.assert_eq_str("positive", classify(10))

    // For loop with sum
    int sum = 0
    int[] nums = [1, 2, 3, 4, 5]
    for n in nums {
        sum += n
    }
    t.assert_eq_int(15, sum)

    // For loop with strings
    str[] words = ["a", "b", "c"]
    int count = 0
    for w in words {
        count += 1
    }
    t.assert_eq_int(3, count)

    // Match with literals
    t.assert_eq_str("perfect", grade(100))
    t.assert_eq_str("A", grade(90))
    t.assert_eq_str("B", grade(80))
    t.assert_eq_str("other", grade(50))

    // Match tuple
    int a = 1
    int b = 0
    str tuple_result = match (a, b) {
        (0, 0) -> "both zero",
        (0, 1) -> "a zero",
        (1, 0) -> "b zero",
        _ -> "neither"
    }
    t.assert_eq_str("b zero", tuple_result)

    // Logical operators
    bool x = true
    bool y = false
    t.assert_true(x && true)
    t.assert_false(x && y)
    t.assert_true(x || y)
    t.assert_false(y || false)
    t.assert_true(!y)
    t.assert_false(!x)

    t.summary()
}
