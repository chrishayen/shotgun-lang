// Variant tests

Option :: variant {
    Some { value int }
    None
}

Result :: variant {
    Ok { value str }
    Err { message str }
}

fn unwrap_or(Option opt, int fallback) int {
    return match opt using Option {
        Some { value: v } -> v,
        None -> fallback
    }
}

fn is_some(Option opt) bool {
    return match opt using Option {
        Some { value: v } -> true,
        None -> false
    }
}

fn main {
    t := new_test()

    // Create variants
    Option some_val = Option.Some { value: 42 }
    Option none_val = Option.None

    // Match and extract values
    t.assert_eq_int(42, unwrap_or(some_val, 0))
    t.assert_eq_int(0, unwrap_or(none_val, 0))
    t.assert_eq_int(99, unwrap_or(none_val, 99))

    // Boolean checks
    t.assert_true(is_some(some_val))
    t.assert_false(is_some(none_val))

    // Result variant
    Result ok = Result.Ok { value: "success" }
    Result err = Result.Err { message: "failed" }

    str ok_msg = match ok using Result {
        Ok { value: v } -> v,
        Err { message: m } -> "error"
    }
    t.assert_eq_str("success", ok_msg)

    str err_msg = match err using Result {
        Ok { value: v } -> "ok",
        Err { message: m } -> m
    }
    t.assert_eq_str("failed", err_msg)

    // Wildcard matching
    int result = match some_val using Option {
        Some { value: v } -> v * 2,
        _ -> 0
    }
    t.assert_eq_int(84, result)

    t.summary()
}
