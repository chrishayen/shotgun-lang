// Closure tests
uses: bootstrap.test

fn apply_int(int x, fn(int) int f) int {
    return f(x)
}

fn apply_twice(int x, fn(int) int f) int {
    return f(f(x))
}

fn main {
    t := new_test()

    // Basic anonymous function
    int doubled = apply_int(5, fn(int n) { return n * 2 })
    t.assert_eq_int(10, doubled)

    // Multiple applications
    int quadrupled = apply_twice(3, fn(int n) { return n * 2 })
    t.assert_eq_int(12, quadrupled)

    // Closure capturing outer variable
    int factor = 10
    int result = apply_int(5, fn(int n) { return n * factor })
    t.assert_eq_int(50, result)

    // Closure capturing multiple variables
    int a = 2
    int b = 3
    int sum_result = apply_int(4, fn(int n) { return n + a + b })
    t.assert_eq_int(9, sum_result)

    // Different operations
    int squared = apply_int(7, fn(int n) { return n * n })
    t.assert_eq_int(49, squared)

    int incremented = apply_int(10, fn(int n) { return n + 1 })
    t.assert_eq_int(11, incremented)

    // Nested closures
    int outer = 100
    int nested = apply_int(5, fn(int n) { return n + outer })
    t.assert_eq_int(105, nested)

    t.summary()
}
