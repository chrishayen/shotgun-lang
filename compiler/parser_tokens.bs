// Token inspection and expectation methods for the parser
//
// This file contains:
// - is_*() methods: Check if current token matches a specific type
// - expect_*() methods: Assert current token and advance, or error
// - get_*() methods: Extract values from current token

// Check if current token matches a keyword
Parser :: is_keyword(self, str name) bool {
    return match self.current.token using Token {
        TkKeyword { name: n } -> n == name,
        _ -> false
    }
}

// Check if current token is a specific type
Parser :: is_type_ident(self) bool { return self.current.token is TkTypeIdent }
Parser :: is_ident(self) bool { return self.current.token is TkIdent }
Parser :: is_int(self) bool { return self.current.token is TkInt }
Parser :: is_float(self) bool { return self.current.token is TkFloat }
Parser :: is_string(self) bool { return self.current.token is TkString }
Parser :: is_char(self) bool { return self.current.token is TkChar }
Parser :: is_eof(self) bool { return self.current.token is TkEof }
Parser :: is_newline(self) bool { return self.current.token is TkNewline }
Parser :: is_lparen(self) bool { return self.current.token is TkLParen }
Parser :: is_rparen(self) bool { return self.current.token is TkRParen }
Parser :: is_lbrace(self) bool { return self.current.token is TkLBrace }
Parser :: is_rbrace(self) bool { return self.current.token is TkRBrace }
Parser :: is_lbracket(self) bool { return self.current.token is TkLBracket }
Parser :: is_rbracket(self) bool { return self.current.token is TkRBracket }
Parser :: is_comma(self) bool { return self.current.token is TkComma }
Parser :: is_colon(self) bool { return self.current.token is TkColon }
Parser :: is_coloncolon(self) bool { return self.current.token is TkColonColon }
Parser :: is_coloneq(self) bool { return self.current.token is TkColonEq }
Parser :: is_dot(self) bool { return self.current.token is TkDot }
Parser :: is_arrow(self) bool { return self.current.token is TkArrow }
Parser :: is_question(self) bool { return self.current.token is TkQuestion }
Parser :: is_underscore(self) bool { return self.current.token is TkUnderscore }
Parser :: is_eq(self) bool { return self.current.token is TkEq }
Parser :: is_plus(self) bool { return self.current.token is TkPlus }
Parser :: is_minus(self) bool { return self.current.token is TkMinus }
Parser :: is_star(self) bool { return self.current.token is TkStar }
Parser :: is_slash(self) bool { return self.current.token is TkSlash }
Parser :: is_percent(self) bool { return self.current.token is TkPercent }
Parser :: is_eqeq(self) bool { return self.current.token is TkEqEq }
Parser :: is_neq(self) bool { return self.current.token is TkNeq }
Parser :: is_lt(self) bool { return self.current.token is TkLt }
Parser :: is_gt(self) bool { return self.current.token is TkGt }
Parser :: is_lte(self) bool { return self.current.token is TkLte }
Parser :: is_gte(self) bool { return self.current.token is TkGte }
Parser :: is_andand(self) bool { return self.current.token is TkAndAnd }
Parser :: is_oror(self) bool { return self.current.token is TkOrOr }
Parser :: is_bang(self) bool { return self.current.token is TkBang }
Parser :: is_pluseq(self) bool { return self.current.token is TkPlusEq }
Parser :: is_minuseq(self) bool { return self.current.token is TkMinusEq }
Parser :: is_stareq(self) bool { return self.current.token is TkStarEq }
Parser :: is_slasheq(self) bool { return self.current.token is TkSlashEq }

// Expect a specific keyword, error if not present
Parser :: expect_keyword(self, str name) bool {
    if self.is_keyword(name) {
        self.advance()
        return true
    }
    print("Error: expected keyword '{name}' at {self.current.location.format()}")
    return false
}

Parser :: expect_lparen(self) bool {
    if self.is_lparen() {
        self.advance()
        return true
    }
    print("Error: expected '(' at {self.current.location.format()}")
    return false
}

Parser :: expect_rparen(self) bool {
    if self.is_rparen() {
        self.advance()
        return true
    }
    print("Error: expected ')' at {self.current.location.format()}")
    return false
}

Parser :: expect_lbrace(self) bool {
    if self.is_lbrace() {
        self.advance()
        return true
    }
    print("Error: expected '\{' at {self.current.location.format()}")
    return false
}

Parser :: expect_rbrace(self) bool {
    if self.is_rbrace() {
        self.advance()
        return true
    }
    print("Error: expected '\}' at {self.current.location.format()}")
    return false
}

Parser :: expect_lbracket(self) bool {
    if self.is_lbracket() {
        self.advance()
        return true
    }
    print("Error: expected '[' at {self.current.location.format()}")
    return false
}

Parser :: expect_rbracket(self) bool {
    if self.is_rbracket() {
        self.advance()
        return true
    }
    print("Error: expected ']' at {self.current.location.format()}")
    return false
}

Parser :: expect_colon(self) bool {
    if self.is_colon() {
        self.advance()
        return true
    }
    print("Error: expected ':' at {self.current.location.format()}")
    return false
}

Parser :: expect_coloncolon(self) bool {
    if self.is_coloncolon() {
        self.advance()
        return true
    }
    print("Error: expected '::' at {self.current.location.format()}")
    return false
}

Parser :: expect_eq(self) bool {
    if self.is_eq() {
        self.advance()
        return true
    }
    print("Error: expected '=' at {self.current.location.format()}")
    return false
}

Parser :: expect_arrow(self) bool {
    if self.is_arrow() {
        self.advance()
        return true
    }
    print("Error: expected '->' at {self.current.location.format()}")
    return false
}

Parser :: expect_gt(self) bool {
    if self.is_gt() {
        self.advance()
        return true
    }
    print("Error: expected '>' at {self.current.location.format()}")
    return false
}

Parser :: expect_dot(self) bool {
    if self.is_dot() {
        self.advance()
        return true
    }
    print("Error: expected '.' at {self.current.location.format()}")
    return false
}

// Get the name from current ident token
Parser :: get_ident(self) str {
    return match self.current.token using Token {
        TkIdent { name: n } -> n,
        _ -> ""
    }
}

Parser :: get_type_ident(self) str {
    return match self.current.token using Token {
        TkTypeIdent { name: n } -> n,
        _ -> ""
    }
}

Parser :: get_int(self) int {
    return match self.current.token using Token {
        TkInt { value: v } -> v,
        _ -> 0
    }
}

Parser :: get_float(self) f64 {
    return match self.current.token using Token {
        TkFloat { value: v } -> v,
        _ -> 0.0
    }
}

Parser :: get_string(self) str {
    return match self.current.token using Token {
        TkString { value: v } -> v,
        _ -> ""
    }
}

Parser :: get_char(self) char {
    return match self.current.token using Token {
        TkChar { value: v } -> v,
        _ -> '\0'
    }
}
