// AST definitions for the Shotgun self-hosted compiler

// Source location for error reporting
Location :: struct {
    line int
    col int
    file str
}

fn dummy_loc() Location {
    return Location { line: 0, col: 0, file: "" }
}

// Wrapper structs for arrays (arrays in variant fields aren't supported)
TypeList :: struct { items Type[] }
StringList :: struct { items str[] }
StringPartList :: struct { items StringPart[] }
FieldInitList :: struct { items FieldInit[] }
PatternList :: struct { items Pattern[] }
PatternBindingList :: struct { items PatternBinding[] }
MatchArmList :: struct { items MatchArm[] }
ParamList :: struct { items Param[] }
ExprList :: struct { items Expr[] }
StmtList :: struct { items Stmt[] }
FieldList :: struct { items Field[] }
EnumVariantList :: struct { items EnumVariant[] }
TraitMethodList :: struct { items TraitMethod[] }
ImplMethodList :: struct { items ImplMethod[] }
ImportPathList :: struct { items ImportPath[] }
ItemList :: struct { items Item[] }

// Pattern binding for variant destructuring: field_name: binding_name
PatternBinding :: struct {
    field_name str
    binding str
}

// Types
Type :: variant {
    TInt
    TStr
    TBool
    TChar
    TF32
    TF64
    TU32
    TU64
    TOptional { inner Type }
    TArray { elem Type }
    TChan { elem Type }
    TUser { name str }
    TResult {
        value Type
        err_type str
    }
    TVoid
    TParam { name str }
    TApply {
        name str
        args TypeList
    }
    TFunc {
        params TypeList
        ret Type?
    }
}

// Binary operators
Binop :: variant {
    Add
    Sub
    Mul
    Div
    Mod
    Eq
    Neq
    Lt
    Gt
    Lte
    Gte
    And
    Or
    In
}

// Unary operators
Unop :: variant {
    Not
}

// Assignment operators
Assignop :: variant {
    Assign
    AddAssign
    SubAssign
    MulAssign
    DivAssign
}

// String interpolation parts
StringPart :: variant {
    SLiteral { value str }
    SInterp { expr Expr }
}

// Field initialization in struct/enum literals
FieldInit :: struct {
    name str
    value Expr
}


// Or-clause variants
OrClause :: variant {
    OrExpr { expr Expr }
    OrReturn { expr Expr? }
    OrError {
        err_name str
        fields FieldInitList
    }
    OrWait { expr Expr }
}

// Match patterns
Pattern :: variant {
    PIdent { name str }
    PLiteral { expr Expr }
    PVariant {
        typ Type?
        variant_name str
        bindings PatternBindingList
    }
    PWildcard
    PTuple { patterns PatternList }
}

// Match arm
MatchArm :: struct {
    pattern Pattern
    expr Expr
}

// Function/method parameter
Param :: variant {
    PSelf
    PNamed {
        typ Type
        name str
    }
}

// Expressions
Expr :: variant {
    EInt { value int }
    EFloat { value f64 }
    EString { parts StringPartList }
    EBool { value bool }
    EChar { value char }
    ENone
    EIdent { name str }
    EBinary {
        op Binop
        left Expr
        right Expr
    }
    EUnary {
        op Unop
        expr Expr
    }
    ECall {
        callee Expr
        type_args TypeList
        args ExprList
    }
    EMember {
        expr Expr
        member str
    }
    EIndex {
        expr Expr
        index Expr
    }
    EOr {
        expr Expr
        clause OrClause
    }
    EStructLit {
        name str
        type_args TypeList
        fields FieldInitList
    }
    EEnumVariant {
        enum_name str
        type_args TypeList
        variant_name str
        fields FieldInitList
    }
    EArrayLit { elements ExprList }
    EChan
    EParen { expr Expr }
    EAssign {
        op Assignop
        target Expr
        value Expr
    }
    EMatch {
        exprs ExprList
        using_type Type?
        arms MatchArmList
    }
    EAnonFn {
        params ParamList
        ret Type?
        body StmtList
        captures StringList
    }
}

// Statements
Stmt :: variant {
    SVarDecl {
        typ Type
        name str
        init Expr
    }
    SVarDeclInfer {
        name str
        init Expr
    }
    SConstDecl {
        name str
        init Expr
    }
    SReturn { expr Expr? }
    SIf {
        cond Expr
        then_block StmtList
        else_block StmtList?
    }
    SFor {
        var str
        var2 str?
        iter Expr
        body StmtList
    }
    SBreak
    SContinue
    SWhile {
        cond Expr
        body StmtList
    }
    SGo { expr Expr }
    SExpr { expr Expr }
}

// Struct field definition
Field :: struct {
    name str
    typ Type
}

// Enum variant definition
EnumVariant :: struct {
    name str
    fields FieldList
}

// Trait method signature
TraitMethod :: struct {
    name str
    params ParamList
    has_self bool
    ret Type?
}

// Impl method definition
ImplMethod :: struct {
    name str
    params ParamList
    ret Type?
    body StmtList
}

// Import path
ImportPath :: struct {
    parts StringList
}

// Top-level items
Item :: variant {
    IStruct {
        name str
        type_params StringList
        fields FieldList
    }
    IEnum {
        name str
        type_params StringList
        variants EnumVariantList
    }
    ITrait {
        name str
        methods TraitMethodList
    }
    IImpl {
        type_name str
        trait_name str
        methods ImplMethodList
    }
    IMethod {
        type_name str
        method_name str
        type_params StringList
        params ParamList
        ret Type?
        body StmtList
    }
    IFunction {
        name str
        type_params StringList
        params ParamList
        ret Type?
        body StmtList
    }
    IError {
        name str
        fields FieldList
    }
    IUses { paths ImportPathList }
}

// A program is a list of top-level items
Program :: struct {
    items ItemList
}

// Simple show method - just print item count for now
Program :: show(self) str {
    count := self.items.items.len()
    return "Program with items"
}
