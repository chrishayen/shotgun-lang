// String interpolation parsing for the parser
//
// This file handles parsing string literals with interpolation:
// - Splitting strings into literal parts and interpolation expressions
// - Parsing interpolation expressions (identifier or member access)

// Parse string interpolation parts from a raw string value
// Splits string into literal parts and interpolation expressions
// Examples:
//   "hello"           -> [SLiteral("hello")]
//   "hi {name}"       -> [SLiteral("hi "), SInterp(name)]
//   "{a} + {b} = {c}" -> [SInterp(a), SLiteral(" + "), SInterp(b), ...]
fn parse_string_parts(str s) StringPart[] {
    StringPart[] parts = []
    current := ""
    i := 0

    while i < s.len() {
        ch := s.at(i)

        if ch == '\\' {
            if i + 1 >= s.len() {
                current = current + ch.to_string()
                i = i + 1
                continue
            }
            next := s.at(i + 1)
            if next == 'n' {
                current = current + "\n"
                i = i + 2
                continue
            }
            if next == 'r' {
                current = current + "\r"
                i = i + 2
                continue
            }
            if next == 't' {
                current = current + "\t"
                i = i + 2
                continue
            }
            if next == '\\' {
                current = current + "\\"
                i = i + 2
                continue
            }
            if next == '"' {
                current = current + "\""
                i = i + 2
                continue
            }
            if next == '{' {
                current = current + "\{"
                i = i + 2
                continue
            }
            current = current + ch.to_string()
            i = i + 1
            continue
        }

        if ch == '{' {
            if current.len() > 0 {
                parts.push(StringPart.SLiteral { value: current })
                current = ""
            }

            i = i + 1
            interp := ""
            depth := 1
            while i < s.len() && depth > 0 {
                c := s.at(i)
                if c == '{' {
                    depth = depth + 1
                } else if c == '}' {
                    depth = depth - 1
                }
                if depth > 0 {
                    interp = interp + c.to_string()
                }
                i = i + 1
            }

            parts.push(StringPart.SInterp { expr: parse_interp_expr(interp) })
            continue
        }

        current = current + ch.to_string()
        i = i + 1
    }

    if current.len() > 0 {
        parts.push(StringPart.SLiteral { value: current })
    }

    return parts
}

// Parse a simple interpolation expression (identifier or member access)
// Examples:
//   name        -> EIdent("name")
//   obj.field   -> EMember(EIdent("obj"), "field")
//   a.b.c       -> EMember(EMember(EIdent("a"), "b"), "c")
fn parse_interp_expr(str s) Expr {
    parts := s.split(".")
    if parts.len() == 0 {
        return Expr.EIdent { name: s }
    }

    Expr result = Expr.EIdent { name: parts[0] }
    i := 1
    while i < parts.len() {
        result = Expr.EMember { expr: result, member: parts[i] }
        i = i + 1
    }

    return result
}
