// C Code Generation for the Shotgun self-hosted compiler
//
// This module transforms a typed AST into C source code.

// Codegen state
CodegenState :: struct {
    lines         str[]      // Output buffer as lines
    current_line  str        // Current line being built
    indent        int        // Current indentation level
    match_counter int        // For unique match temp variables
    env           Env        // Semantic environment for type lookups
}

// Create a new codegen state
fn create_state(Env env) CodegenState {
    return CodegenState {
        lines: [],
        current_line: "",
        indent: 0,
        match_counter: 0,
        env: env
    }
}

// Emit a string to the current line
fn emit(CodegenState state, str s) {
    state.current_line = state.current_line + s
}

// Emit a string and end the line
fn emitln(CodegenState state, str s) {
    state.current_line = state.current_line + s
    state.lines.push(state.current_line)
    state.current_line = ""
}

// Emit just a newline (end current line)
fn newline(CodegenState state) {
    state.lines.push(state.current_line)
    state.current_line = ""
}

// Emit indentation
fn emit_indent(CodegenState state) {
    i := 0
    while i < state.indent {
        emit(state, "    ")
        i += 1
    }
}

// Get the final output as a single string
fn get_output(CodegenState state) str {
    // If there's a pending line, add it
    if state.current_line.len() > 0 {
        state.lines.push(state.current_line)
        state.current_line = ""
    }

    // Join all lines with newlines
    result := ""
    i := 0
    while i < state.lines.len() {
        if i > 0 {
            result = result + "\n"
        }
        result = result + state.lines[i]
        i += 1
    }
    return result
}

// Generate the C prelude (includes and runtime)
fn gen_prelude(CodegenState state) {
    emitln(state, "/* Generated by Shotgun compiler */")
    emitln(state, "#define _POSIX_C_SOURCE 200809L")
    emitln(state, "#include <inttypes.h>")
    emitln(state, "#include <stdio.h>")
    emitln(state, "#include <stdlib.h>")
    emitln(state, "#include <stdint.h>")
    emitln(state, "#include <stdbool.h>")
    emitln(state, "#include <string.h>")
    emitln(state, "#include <stdarg.h>")
    emitln(state, "#include <unistd.h>")
    emitln(state, "#include <pthread.h>")
    emitln(state, "")
    // Note: Runtime support will be added incrementally
}

// Main code generation entry point
fn generate(Env env, Program program) str {
    state := create_state(env)

    // Generate C prelude
    gen_prelude(state)

    // Collect struct names for array typedef generation
    str[] struct_names = []

    // Forward declarations for structs and enums (non-generic only)
    i := 0
    items := program.items.items
    while i < items.len() {
        item := items[i]
        if item is IStruct {
            if item.type_params.items.len() == 0 {
                gen_struct_fwd(state, item.name)
                struct_names.push(item.name)
            }
        }
        if item is IEnum {
            if item.type_params.items.len() == 0 {
                gen_enum_fwd(state, item.name)
            }
        }
        if item is IError {
            gen_struct_fwd(state, item.name)
        }
        i += 1
    }

    // Generate array typedefs for user structs
    i = 0
    while i < struct_names.len() {
        gen_array_typedef(state, struct_names[i])
        i += 1
    }

    // Generate struct and enum definitions (non-generic only)
    i = 0
    while i < items.len() {
        item := items[i]
        if item is IStruct {
            if item.type_params.items.len() == 0 {
                gen_struct(state, item.name, item.fields.items)
            }
        }
        if item is IEnum {
            if item.type_params.items.len() == 0 {
                gen_enum(state, item.name, item.variants.items)
            }
        }
        if item is IError {
            gen_struct(state, item.name, item.fields.items)
        }
        i += 1
    }

    // Forward declarations for functions and methods (non-generic only)
    newline(state)
    emitln(state, "/* Forward declarations */")
    i = 0
    while i < items.len() {
        item := items[i]
        if item is IFunction {
            if item.type_params.items.len() == 0 {
                gen_function_decl(state, item.name, item.params.items, item.ret)
            }
        }
        if item is IMethod {
            if item.type_params.items.len() == 0 {
                gen_method_decl(state, item.type_name, item.method_name, item.params.items, item.ret)
            }
        }
        if item is IImpl {
            j := 0
            methods := item.methods.items
            while j < methods.len() {
                m := methods[j]
                gen_method_decl(state, item.type_name, m.name, m.params.items, m.ret)
                j += 1
            }
        }
        i += 1
    }

    // Generate function and method bodies (non-generic only)
    i = 0
    while i < items.len() {
        item := items[i]
        if item is ITrait {
            // Traits are just comments
            newline(state)
            emit(state, "/* trait ")
            emit(state, item.name)
            emitln(state, " */")
        }
        if item is IImpl {
            gen_impl(state, item.type_name, item.trait_name, item.methods.items)
        }
        if item is IMethod {
            if item.type_params.items.len() == 0 {
                gen_method(state, item.type_name, item.method_name, item.params.items, item.body.items, item.ret)
            }
        }
        if item is IFunction {
            if item.type_params.items.len() == 0 {
                gen_function(state, item.name, item.params.items, item.body.items, item.ret)
            }
        }
        i += 1
    }

    return get_output(state)
}
