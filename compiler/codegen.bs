// C Code Generation for the Shotgun self-hosted compiler
//
// This module transforms a typed AST into C source code.

// Codegen state
CodegenState :: struct {
    lines         str[]      // Output buffer as lines
    current_line  str        // Current line being built
    indent        int        // Current indentation level
    match_counter int        // For unique match temp variables
    env           Env        // Semantic environment for type lookups
}

// Create a new codegen state
fn create_state(Env env) CodegenState {
    return CodegenState {
        lines: [],
        current_line: "",
        indent: 0,
        match_counter: 0,
        env: env
    }
}

// Emit a string to the current line
fn emit(CodegenState state, str s) {
    state.current_line = state.current_line + s
}

// Emit a string and end the line
fn emitln(CodegenState state, str s) {
    state.current_line = state.current_line + s
    state.lines.push(state.current_line)
    state.current_line = ""
}

// Emit just a newline (end current line)
fn newline(CodegenState state) {
    state.lines.push(state.current_line)
    state.current_line = ""
}

// Emit indentation
fn emit_indent(CodegenState state) {
    i := 0
    while i < state.indent {
        emit(state, "    ")
        i += 1
    }
}

// Get the final output as a single string
fn get_output(CodegenState state) str {
    // If there's a pending line, add it
    if state.current_line.len() > 0 {
        state.lines.push(state.current_line)
        state.current_line = ""
    }

    // Join all lines with newlines
    result := ""
    i := 0
    while i < state.lines.len() {
        if i > 0 {
            result = result + "\n"
        }
        result = result + state.lines[i]
        i += 1
    }
    return result
}

// Generate the C prelude (includes and runtime)
fn gen_prelude(CodegenState state) {
    emitln(state, "/* Generated by Shotgun compiler */")
    emitln(state, "#define _POSIX_C_SOURCE 200809L")
    emitln(state, "#include <inttypes.h>")
    emitln(state, "#include <stdio.h>")
    emitln(state, "#include <stdlib.h>")
    emitln(state, "#include <stdint.h>")
    emitln(state, "#include <stdbool.h>")
    emitln(state, "#include <string.h>")
    emitln(state, "#include <stdarg.h>")
    emitln(state, "#include <unistd.h>")
    emitln(state, "#include <pthread.h>")
    emitln(state, "")
    gen_runtime(state)
}

// Generate the C runtime support functions
fn gen_runtime(CodegenState state) {
    emitln(state, "/* Runtime support */")

    // String formatting (for string interpolation)
    emitln(state, "static char* shotgun_format(const char* fmt, ...) \{")
    emitln(state, "    va_list args;")
    emitln(state, "    va_start(args, fmt);")
    emitln(state, "    int len = vsnprintf(NULL, 0, fmt, args);")
    emitln(state, "    va_end(args);")
    emitln(state, "    char* buf = malloc(len + 1);")
    emitln(state, "    va_start(args, fmt);")
    emitln(state, "    vsnprintf(buf, len + 1, fmt, args);")
    emitln(state, "    va_end(args);")
    emitln(state, "    return buf;")
    emitln(state, "}")
    emitln(state, "")

    // Allocation helper
    emitln(state, "static void* shotgun_alloc_copy(size_t size, void* src) \{")
    emitln(state, "    void* p = malloc(size);")
    emitln(state, "    memcpy(p, src, size);")
    emitln(state, "    return p;")
    emitln(state, "}")
    emitln(state, "")

    // String concat
    emitln(state, "static char* shotgun_concat(char* a, char* b) \{")
    emitln(state, "    size_t len_a = strlen(a);")
    emitln(state, "    size_t len_b = strlen(b);")
    emitln(state, "    char* result = malloc(len_a + len_b + 1);")
    emitln(state, "    memcpy(result, a, len_a);")
    emitln(state, "    memcpy(result + len_a, b, len_b + 1);")
    emitln(state, "    return result;")
    emitln(state, "}")
    emitln(state, "")

    // String slice
    emitln(state, "static char* shotgun_str_slice(char* s, int64_t start, int64_t end) \{")
    emitln(state, "    int64_t len = end - start;")
    emitln(state, "    char* result = malloc(len + 1);")
    emitln(state, "    memcpy(result, s + start, len);")
    emitln(state, "    result[len] = '\\0';")
    emitln(state, "    return result;")
    emitln(state, "}")
    emitln(state, "")

    // String find
    emitln(state, "static int64_t shotgun_str_find(char* s, char* substr) \{")
    emitln(state, "    char* pos = strstr(s, substr);")
    emitln(state, "    return pos ? (int64_t)(pos - s) : -1;")
    emitln(state, "}")
    emitln(state, "")

    // String ends_with
    emitln(state, "static bool shotgun_str_ends_with(char* s, char* suffix) \{")
    emitln(state, "    size_t slen = strlen(s);")
    emitln(state, "    size_t suffixlen = strlen(suffix);")
    emitln(state, "    if (suffixlen > slen) return false;")
    emitln(state, "    return strcmp(s + slen - suffixlen, suffix) == 0;")
    emitln(state, "}")
    emitln(state, "")

    // String trim
    emitln(state, "static char* shotgun_str_trim(char* s) \{")
    emitln(state, "    while (*s && (*s == ' ' || *s == '\\t' || *s == '\\n' || *s == '\\r')) s++;")
    emitln(state, "    if (*s == 0) return strdup(\"\");")
    emitln(state, "    char* end = s + strlen(s) - 1;")
    emitln(state, "    while (end > s && (*end == ' ' || *end == '\\t' || *end == '\\n' || *end == '\\r')) end--;")
    emitln(state, "    size_t len = end - s + 1;")
    emitln(state, "    char* result = malloc(len + 1);")
    emitln(state, "    memcpy(result, s, len);")
    emitln(state, "    result[len] = '\\0';")
    emitln(state, "    return result;")
    emitln(state, "}")
    emitln(state, "")

    // String replace
    emitln(state, "static char* shotgun_str_replace(char* s, char* old, char* new_s) \{")
    emitln(state, "    size_t old_len = strlen(old);")
    emitln(state, "    size_t new_len = strlen(new_s);")
    emitln(state, "    size_t count = 0;")
    emitln(state, "    char* tmp = s;")
    emitln(state, "    while ((tmp = strstr(tmp, old))) \{ count++; tmp += old_len; }")
    emitln(state, "    size_t result_len = strlen(s) + count * (new_len - old_len);")
    emitln(state, "    char* result = malloc(result_len + 1);")
    emitln(state, "    char* dst = result;")
    emitln(state, "    while (*s) \{")
    emitln(state, "        if (strncmp(s, old, old_len) == 0) \{")
    emitln(state, "            memcpy(dst, new_s, new_len);")
    emitln(state, "            dst += new_len;")
    emitln(state, "            s += old_len;")
    emitln(state, "        } else \{")
    emitln(state, "            *dst++ = *s++;")
    emitln(state, "        }")
    emitln(state, "    }")
    emitln(state, "    *dst = '\\0';")
    emitln(state, "    return result;")
    emitln(state, "}")
    emitln(state, "")

    // String to_upper/to_lower
    emitln(state, "static char* shotgun_str_to_upper(char* s) \{")
    emitln(state, "    size_t len = strlen(s);")
    emitln(state, "    char* result = malloc(len + 1);")
    emitln(state, "    for (size_t i = 0; i <= len; i++) \{")
    emitln(state, "        result[i] = (s[i] >= 'a' && s[i] <= 'z') ? s[i] - 32 : s[i];")
    emitln(state, "    }")
    emitln(state, "    return result;")
    emitln(state, "}")
    emitln(state, "")

    emitln(state, "static char* shotgun_str_to_lower(char* s) \{")
    emitln(state, "    size_t len = strlen(s);")
    emitln(state, "    char* result = malloc(len + 1);")
    emitln(state, "    for (size_t i = 0; i <= len; i++) \{")
    emitln(state, "        result[i] = (s[i] >= 'A' && s[i] <= 'Z') ? s[i] + 32 : s[i];")
    emitln(state, "    }")
    emitln(state, "    return result;")
    emitln(state, "}")
    emitln(state, "")

    // Char to string
    emitln(state, "static char* shotgun_char_to_string(char c) \{")
    emitln(state, "    char* result = malloc(2);")
    emitln(state, "    result[0] = c;")
    emitln(state, "    result[1] = '\\0';")
    emitln(state, "    return result;")
    emitln(state, "}")
    emitln(state, "")

    // Array types
    emitln(state, "typedef struct \{ char** data; size_t len; size_t cap; } Array_str;")
    emitln(state, "typedef struct \{ int64_t* data; size_t len; size_t cap; } Array_int64;")
    emitln(state, "typedef struct \{ bool* data; size_t len; size_t cap; } Array_bool;")
    emitln(state, "typedef struct \{ float* data; size_t len; size_t cap; } Array_f32;")
    emitln(state, "typedef struct \{ double* data; size_t len; size_t cap; } Array_f64;")
    emitln(state, "")

    // String split
    emitln(state, "static Array_str* shotgun_str_split(char* s, char* delim) \{")
    emitln(state, "    size_t delim_len = strlen(delim);")
    emitln(state, "    size_t count = 1;")
    emitln(state, "    char* tmp = s;")
    emitln(state, "    while ((tmp = strstr(tmp, delim))) \{ count++; tmp += delim_len; }")
    emitln(state, "    Array_str* arr = malloc(sizeof(Array_str));")
    emitln(state, "    arr->data = malloc(sizeof(char*) * count);")
    emitln(state, "    arr->len = count;")
    emitln(state, "    arr->cap = count;")
    emitln(state, "    size_t i = 0;")
    emitln(state, "    char* start = s;")
    emitln(state, "    while ((tmp = strstr(start, delim))) \{")
    emitln(state, "        size_t part_len = tmp - start;")
    emitln(state, "        arr->data[i] = malloc(part_len + 1);")
    emitln(state, "        memcpy(arr->data[i], start, part_len);")
    emitln(state, "        arr->data[i][part_len] = '\\0';")
    emitln(state, "        i++;")
    emitln(state, "        start = tmp + delim_len;")
    emitln(state, "    }")
    emitln(state, "    arr->data[i] = strdup(start);")
    emitln(state, "    return arr;")
    emitln(state, "}")
    emitln(state, "")

    // File I/O
    emitln(state, "static char* shotgun_read_file(char* path) \{")
    emitln(state, "    FILE* f = fopen(path, \"r\");")
    emitln(state, "    if (!f) return NULL;")
    emitln(state, "    fseek(f, 0, SEEK_END);")
    emitln(state, "    long len = ftell(f);")
    emitln(state, "    fseek(f, 0, SEEK_SET);")
    emitln(state, "    char* buf = malloc(len + 1);")
    emitln(state, "    fread(buf, 1, len, f);")
    emitln(state, "    buf[len] = '\\0';")
    emitln(state, "    fclose(f);")
    emitln(state, "    return buf;")
    emitln(state, "}")
    emitln(state, "")

    emitln(state, "static void shotgun_write_file(char* path, char* content) \{")
    emitln(state, "    FILE* f = fopen(path, \"w\");")
    emitln(state, "    if (f) \{")
    emitln(state, "        fputs(content, f);")
    emitln(state, "        fclose(f);")
    emitln(state, "    }")
    emitln(state, "}")
    emitln(state, "")

    // Map runtime
    emitln(state, "typedef struct \{")
    emitln(state, "    char* key;")
    emitln(state, "    void* value;")
    emitln(state, "    bool occupied;")
    emitln(state, "    bool deleted;")
    emitln(state, "} ShotgunMapEntry;")
    emitln(state, "")

    emitln(state, "typedef struct \{")
    emitln(state, "    ShotgunMapEntry* buckets;")
    emitln(state, "    size_t capacity;")
    emitln(state, "    size_t size;")
    emitln(state, "    size_t value_size;")
    emitln(state, "} ShotgunMap;")
    emitln(state, "")

    emitln(state, "static uint64_t shotgun_hash_str(const char* s) \{")
    emitln(state, "    uint64_t h = 14695981039346656037ULL;")
    emitln(state, "    while (*s) \{ h ^= (uint64_t)*s++; h *= 1099511628211ULL; }")
    emitln(state, "    return h;")
    emitln(state, "}")
    emitln(state, "")

    emitln(state, "static ShotgunMap* shotgun_map_create(size_t value_size) \{")
    emitln(state, "    ShotgunMap* m = malloc(sizeof(ShotgunMap));")
    emitln(state, "    m->capacity = 16;")
    emitln(state, "    m->size = 0;")
    emitln(state, "    m->value_size = value_size;")
    emitln(state, "    m->buckets = calloc(m->capacity, sizeof(ShotgunMapEntry));")
    emitln(state, "    return m;")
    emitln(state, "}")
    emitln(state, "")

    emitln(state, "static bool shotgun_map_has(ShotgunMap* m, char* key) \{")
    emitln(state, "    uint64_t h = shotgun_hash_str(key) % m->capacity;")
    emitln(state, "    while (m->buckets[h].occupied) \{")
    emitln(state, "        if (!m->buckets[h].deleted && strcmp(m->buckets[h].key, key) == 0) return true;")
    emitln(state, "        h = (h + 1) % m->capacity;")
    emitln(state, "    }")
    emitln(state, "    return false;")
    emitln(state, "}")
    emitln(state, "")

    emitln(state, "static void shotgun_map_delete(ShotgunMap* m, char* key) \{")
    emitln(state, "    uint64_t h = shotgun_hash_str(key) % m->capacity;")
    emitln(state, "    while (m->buckets[h].occupied) \{")
    emitln(state, "        if (!m->buckets[h].deleted && strcmp(m->buckets[h].key, key) == 0) \{")
    emitln(state, "            m->buckets[h].deleted = true;")
    emitln(state, "            m->size--;")
    emitln(state, "            return;")
    emitln(state, "        }")
    emitln(state, "        h = (h + 1) % m->capacity;")
    emitln(state, "    }")
    emitln(state, "}")
    emitln(state, "")

    emitln(state, "static size_t shotgun_map_len(ShotgunMap* m) \{ return m->size; }")
    emitln(state, "")
}

// Main code generation entry point
fn generate(Env env, Program program) str {
    state := create_state(env)

    // Generate C prelude
    gen_prelude(state)

    // Collect struct names for array typedef generation
    str[] struct_names = []

    // Forward declarations for structs and enums (non-generic only)
    i := 0
    items := program.items.items
    while i < items.len() {
        item := items[i]
        if item is IStruct {
            if item.type_params.items.len() == 0 {
                gen_struct_fwd(state, item.name)
                struct_names.push(item.name)
            }
        }
        if item is IEnum {
            if item.type_params.items.len() == 0 {
                gen_enum_fwd(state, item.name)
            }
        }
        if item is IError {
            gen_struct_fwd(state, item.name)
        }
        i += 1
    }

    // Generate array typedefs for user structs
    i = 0
    while i < struct_names.len() {
        gen_array_typedef(state, struct_names[i])
        i += 1
    }

    // Generate struct and enum definitions (non-generic only)
    i = 0
    while i < items.len() {
        item := items[i]
        if item is IStruct {
            if item.type_params.items.len() == 0 {
                gen_struct(state, item.name, item.fields.items)
            }
        }
        if item is IEnum {
            if item.type_params.items.len() == 0 {
                gen_enum(state, item.name, item.variants.items)
            }
        }
        if item is IError {
            gen_struct(state, item.name, item.fields.items)
        }
        i += 1
    }

    // Forward declarations for functions and methods (non-generic only)
    newline(state)
    emitln(state, "/* Forward declarations */")
    i = 0
    while i < items.len() {
        item := items[i]
        if item is IFunction {
            if item.type_params.items.len() == 0 {
                gen_function_decl(state, item.name, item.params.items, item.ret)
            }
        }
        if item is IMethod {
            if item.type_params.items.len() == 0 {
                gen_method_decl(state, item.type_name, item.method_name, item.params.items, item.ret)
            }
        }
        if item is IImpl {
            j := 0
            methods := item.methods.items
            while j < methods.len() {
                m := methods[j]
                gen_method_decl(state, item.type_name, m.name, m.params.items, m.ret)
                j += 1
            }
        }
        i += 1
    }

    // Generate function and method bodies (non-generic only)
    i = 0
    while i < items.len() {
        item := items[i]
        if item is ITrait {
            // Traits are just comments
            newline(state)
            emit(state, "/* trait ")
            emit(state, item.name)
            emitln(state, " */")
        }
        if item is IImpl {
            gen_impl(state, item.type_name, item.trait_name, item.methods.items)
        }
        if item is IMethod {
            if item.type_params.items.len() == 0 {
                gen_method(state, item.type_name, item.method_name, item.params.items, item.body.items, item.ret)
            }
        }
        if item is IFunction {
            if item.type_params.items.len() == 0 {
                gen_function(state, item.name, item.params.items, item.body.items, item.ret)
            }
        }
        i += 1
    }

    return get_output(state)
}
