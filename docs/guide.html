<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Language Guide - shotgun</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <nav>
        <div class="nav-inner">
            <a href="index.html" class="logo">shotgun</a>
            <div class="links">
                <a href="quickstart.html">Quick Start</a>
                <a href="guide.html">Guide</a>
                <a href="examples.html">Examples</a>
                <a href="https://github.com/chrishayen/shotgun-lang">GitHub</a>
            </div>
        </div>
    </nav>

    <div class="container">
        <h1>Language Guide</h1>

        <p>A complete reference to the shotgun programming language.</p>

        <h2>Basics</h2>

        <h3>Primitive Types</h3>

        <p>shotgun has the following primitive types:</p>

        <ul>
            <li><code>int</code> - 64-bit signed integer</li>
            <li><code>str</code> - string</li>
            <li><code>bool</code> - boolean (<code>true</code> or <code>false</code>)</li>
            <li><code>char</code> - single character (e.g., <code>'a'</code>, <code>'\n'</code>)</li>
        </ul>

        <p>Convert between characters and their integer values using <code>chr()</code> and <code>ord()</code>:</p>

        <pre><code>ch := <span class="fn">chr</span>(<span class="nu">65</span>)        <span class="cm">// 'A'</span>
code := <span class="fn">ord</span>(<span class="ch">'A'</span>)       <span class="cm">// 65</span>
s := ch.<span class="fn">to_string</span>()   <span class="cm">// "A"</span></code></pre>

        <ul>
            <li><code>f32</code> - 32-bit floating point</li>
            <li><code>f64</code> - 64-bit floating point</li>
            <li><code>u32</code> - 32-bit unsigned integer</li>
            <li><code>u64</code> - 64-bit unsigned integer</li>
        </ul>

        <h3>Variables</h3>

        <p>Variables can be declared with explicit types or use <code>:=</code> for type inference:</p>

        <pre><code><span class="cm">// Explicit type</span>
<span class="ty">int</span> x = <span class="nu">5</span>
<span class="ty">str</span> name = <span class="st">"Alice"</span>

<span class="cm">// Type inferred with :=</span>
y := <span class="nu">10</span>
greeting := <span class="st">"Hello"</span>
nums := [<span class="nu">1</span>, <span class="nu">2</span>, <span class="nu">3</span>]</code></pre>

        <h3>Constants</h3>

        <p>Use <code>const</code> for values that don't change. Type is inferred:</p>

        <pre><code><span class="kw">const</span> max_size = <span class="nu">100</span>
<span class="kw">const</span> greeting = <span class="st">"Hello"</span></code></pre>

        <h3>Comments</h3>

        <pre><code><span class="cm">// This is a single-line comment</span>

<span class="ty">int</span> x = <span class="nu">5</span>  <span class="cm">// inline comment</span></code></pre>

        <h2>Functions</h2>

        <p>Functions are declared with <code>fn</code>:</p>

        <pre><code><span class="kw">fn</span> <span class="fn">greet</span>(<span class="ty">str</span> name) {
    <span class="fn">print</span>(<span class="st">"Hello, {name}!"</span>)
}

<span class="kw">fn</span> <span class="fn">add</span>(<span class="ty">int</span> a, <span class="ty">int</span> b) <span class="ty">int</span> {
    <span class="kw">return</span> a + b
}</code></pre>

        <p>The main entry point is <code>fn main</code>:</p>

        <pre><code><span class="kw">fn</span> <span class="fn">main</span> {
    <span class="fn">greet</span>(<span class="st">"World"</span>)
}</code></pre>

        <h2>Structs</h2>

        <p>Define data structures with <code>struct</code>:</p>

        <pre><code><span class="ty">Person</span> <span class="kw">::</span> <span class="kw">struct</span> {
    name  <span class="ty">str</span>
    age   <span class="ty">int</span>
    email <span class="ty">str?</span>  <span class="cm">// optional field</span>
}</code></pre>

        <p>Create instances with named fields:</p>

        <pre><code>alice := <span class="ty">Person</span> {
    name: <span class="st">"Alice"</span>,
    age: <span class="nu">30</span>,
    email: <span class="st">"alice@example.com"</span>,
}

bob := <span class="ty">Person</span> {
    name: <span class="st">"Bob"</span>,
    age: <span class="nu">25</span>,
}</code></pre>

        <p>Access fields with dot notation:</p>

        <pre><code><span class="fn">print</span>(alice.name)  <span class="cm">// "Alice"</span>
<span class="fn">print</span>(bob.age)     <span class="cm">// 25</span></code></pre>

        <h2>Variants (Sum Types)</h2>

        <p>Variants represent values that can be one of several different types. Each variant can optionally carry data:</p>

        <pre><code><span class="ty">Option</span> <span class="kw">::</span> <span class="kw">variant</span> {
    <span class="ty">Some</span> { value <span class="ty">int</span> }
    <span class="ty">None</span>
}</code></pre>

        <p>Create variant values using dot notation:</p>

        <pre><code>x := <span class="ty">Option</span>.<span class="ty">None</span>
y := <span class="ty">Option</span>.<span class="ty">Some</span> { value: <span class="nu">42</span> }</code></pre>

        <p>Variants are useful for representing mutually exclusive states:</p>

        <pre><code><span class="ty">Response</span> <span class="kw">::</span> <span class="kw">variant</span> {
    <span class="ty">Loading</span>
    <span class="ty">Success</span> { data <span class="ty">str</span> }
    <span class="ty">Error</span> { message <span class="ty">str</span> }
}</code></pre>

        <p>Unlike structs (which have all fields at once), a variant is exactly one of its cases at any time. This makes invalid states unrepresentable.</p>

        <h2>Recursive Types</h2>

        <p>Types can reference themselves, useful for tree structures and ASTs:</p>

        <pre><code><span class="cm">// Recursive struct via arrays</span>
<span class="ty">Node</span> <span class="kw">::</span> <span class="kw">struct</span> {
    value <span class="ty">int</span>
    children <span class="ty">Node</span>[]
}

<span class="cm">// Recursive variant (like an AST)</span>
<span class="ty">Expr</span> <span class="kw">::</span> <span class="kw">variant</span> {
    <span class="ty">Int</span> { value <span class="ty">int</span> }
    <span class="ty">Binary</span> {
        left <span class="ty">Expr</span>
        right <span class="ty">Expr</span>
    }
}</code></pre>

        <p>Recursive variant fields are automatically heap-allocated as pointers:</p>

        <pre><code>a := <span class="ty">Expr</span>.<span class="ty">Int</span> { value: <span class="nu">1</span> }
b := <span class="ty">Expr</span>.<span class="ty">Int</span> { value: <span class="nu">2</span> }
add := <span class="ty">Expr</span>.<span class="ty">Binary</span> { left: a, right: b }</code></pre>

        <h2>Generics</h2>

        <p>Define type-safe containers with type parameters using angle brackets:</p>

        <pre><code><span class="ty">Box</span>&lt;<span class="ty">T</span>&gt; <span class="kw">::</span> <span class="kw">struct</span> {
    value <span class="ty">T</span>
}

<span class="ty">Option</span>&lt;<span class="ty">T</span>&gt; <span class="kw">::</span> <span class="kw">variant</span> {
    <span class="ty">Some</span> { value <span class="ty">T</span> }
    <span class="ty">None</span>
}</code></pre>

        <p>Use generics with concrete types:</p>

        <pre><code>int_box := <span class="ty">Box</span>&lt;<span class="ty">int</span>&gt; { value: <span class="nu">42</span> }
str_box := <span class="ty">Box</span>&lt;<span class="ty">str</span>&gt; { value: <span class="st">"hello"</span> }

maybe := <span class="ty">Option</span>&lt;<span class="ty">int</span>&gt;.<span class="ty">Some</span> { value: <span class="nu">100</span> }
nothing := <span class="ty">Option</span>&lt;<span class="ty">str</span>&gt;.<span class="ty">None</span></code></pre>

        <h3>Multiple Type Parameters</h3>

        <p>Types can have multiple type parameters:</p>

        <pre><code><span class="ty">Pair</span>&lt;<span class="ty">A</span>, <span class="ty">B</span>&gt; <span class="kw">::</span> <span class="kw">struct</span> {
    first  <span class="ty">A</span>
    second <span class="ty">B</span>
}

<span class="ty">Result</span>&lt;<span class="ty">T</span>, <span class="ty">E</span>&gt; <span class="kw">::</span> <span class="kw">variant</span> {
    <span class="ty">Ok</span> { value <span class="ty">T</span> }
    <span class="ty">Err</span> { err <span class="ty">E</span> }
}

p := <span class="ty">Pair</span>&lt;<span class="ty">int</span>, <span class="ty">str</span>&gt; { first: <span class="nu">42</span>, second: <span class="st">"hello"</span> }
ok := <span class="ty">Result</span>&lt;<span class="ty">int</span>, <span class="ty">str</span>&gt;.<span class="ty">Ok</span> { value: <span class="nu">100</span> }</code></pre>

        <h3>Pattern Matching on Generic Variants</h3>

        <p>Use the <code>using</code> clause with the concrete type:</p>

        <pre><code>maybe := <span class="ty">Option</span>&lt;<span class="ty">int</span>&gt;.<span class="ty">Some</span> { value: <span class="nu">42</span> }

result := <span class="kw">match</span> maybe <span class="kw">using</span> <span class="ty">Option</span>&lt;<span class="ty">int</span>&gt; {
    <span class="ty">Some</span> { value: v } -> v,
    <span class="ty">None</span> -> <span class="nu">0</span>
}</code></pre>

        <h2>Methods</h2>

        <p>Add methods to structs with the <code>::</code> syntax:</p>

        <pre><code><span class="ty">Person</span> <span class="kw">::</span> <span class="fn">greet</span>(self) <span class="ty">str</span> {
    <span class="kw">return</span> <span class="st">"Hello, I'm {self.name}!"</span>
}

<span class="ty">Person</span> <span class="kw">::</span> <span class="fn">is_adult</span>(self) <span class="ty">bool</span> {
    <span class="kw">return</span> self.age >= <span class="nu">18</span>
}

<span class="ty">Person</span> <span class="kw">::</span> <span class="fn">birthday</span>(self) {
    self.age += <span class="nu">1</span>
}</code></pre>

        <p>Call methods on instances:</p>

        <pre><code>p := <span class="ty">Person</span> { name: <span class="st">"Alice"</span>, age: <span class="nu">30</span> }
<span class="fn">print</span>(p.<span class="fn">greet</span>())     <span class="cm">// "Hello, I'm Alice!"</span>
<span class="fn">print</span>(p.<span class="fn">is_adult</span>())  <span class="cm">// true</span></code></pre>

        <h3>Methods on Generic Types</h3>

        <p>Generic types can also have methods. The type parameter is available in the method:</p>

        <pre><code><span class="ty">Box</span>&lt;<span class="ty">T</span>&gt; <span class="kw">::</span> <span class="kw">struct</span> {
    value <span class="ty">T</span>
}

<span class="ty">Box</span>&lt;<span class="ty">T</span>&gt; <span class="kw">::</span> <span class="fn">get</span>(self) <span class="ty">T</span> {
    <span class="kw">return</span> self.value
}

<span class="ty">Box</span>&lt;<span class="ty">T</span>&gt; <span class="kw">::</span> <span class="fn">add</span>(self, <span class="ty">T</span> other) <span class="ty">T</span> {
    <span class="kw">return</span> self.value + other
}

<span class="kw">fn</span> <span class="fn">main</span> {
    b := <span class="ty">Box</span>&lt;<span class="ty">int</span>&gt; { value: <span class="nu">10</span> }
    <span class="fn">print</span>(b.<span class="fn">get</span>())        <span class="cm">// 10</span>
    <span class="fn">print</span>(b.<span class="fn">add</span>(<span class="nu">32</span>))      <span class="cm">// 42</span>
}</code></pre>

        <h2>Closures and Higher-Order Functions</h2>

        <p>Functions can be passed as arguments and returned from other functions. Use the <code>fn</code> keyword to define both function types and anonymous functions.</p>

        <h3>Function Types</h3>

        <p>Declare function types using <code>fn(param_types) return_type</code>:</p>

        <pre><code><span class="cm">// A function that takes an int and returns an int</span>
<span class="ty">fn</span>(<span class="ty">int</span>) <span class="ty">int</span>

<span class="cm">// A function that takes two strings and returns a bool</span>
<span class="ty">fn</span>(<span class="ty">str</span>, <span class="ty">str</span>) <span class="ty">bool</span>

<span class="cm">// A function with no return value</span>
<span class="ty">fn</span>(<span class="ty">int</span>)</code></pre>

        <h3>Anonymous Functions</h3>

        <p>Create inline functions with <code>fn(params) { body }</code>. Return types are inferred automatically:</p>

        <pre><code><span class="cm">// Return type inferred as int from body</span>
<span class="kw">fn</span>(<span class="ty">int</span> n) { <span class="kw">return</span> n * <span class="nu">2</span> }

<span class="cm">// Explicit return type (optional)</span>
<span class="kw">fn</span>(<span class="ty">int</span> n) <span class="ty">int</span> { <span class="kw">return</span> n * <span class="nu">2</span> }

<span class="cm">// Void function (no return)</span>
<span class="kw">fn</span>(<span class="ty">str</span> msg) { <span class="fn">print</span>(msg) }</code></pre>

        <h3>Higher-Order Functions</h3>

        <p>Pass functions as arguments to other functions:</p>

        <pre><code><span class="kw">fn</span> <span class="fn">apply</span>(<span class="ty">int</span> x, <span class="ty">fn</span>(<span class="ty">int</span>) <span class="ty">int</span> f) <span class="ty">int</span> {
    <span class="kw">return</span> <span class="fn">f</span>(x)
}

<span class="kw">fn</span> <span class="fn">main</span>() {
    doubled := <span class="fn">apply</span>(<span class="nu">5</span>, <span class="kw">fn</span>(<span class="ty">int</span> n) { <span class="kw">return</span> n * <span class="nu">2</span> })
    <span class="fn">print</span>(doubled)  <span class="cm">// 10</span>
}</code></pre>

        <h3>Variable Capture (Closures)</h3>

        <p>Anonymous functions can capture variables from their enclosing scope:</p>

        <pre><code><span class="kw">fn</span> <span class="fn">main</span>() {
    factor := <span class="nu">10</span>

    <span class="cm">// This closure captures 'factor' from the outer scope</span>
    result := <span class="fn">apply</span>(<span class="nu">5</span>, <span class="kw">fn</span>(<span class="ty">int</span> n) { <span class="kw">return</span> n * factor })
    <span class="fn">print</span>(result)  <span class="cm">// 50</span>
}</code></pre>

        <p>Captured variables are copied by value when the closure is created.</p>

        <h2>Traits</h2>

        <p>Traits define shared behavior:</p>

        <pre><code><span class="ty">Stringer</span> <span class="kw">::</span> <span class="kw">trait</span> {
    <span class="fn">to_string</span>(self) <span class="ty">str</span>
}

<span class="ty">Comparable</span> <span class="kw">::</span> <span class="kw">trait</span> {
    <span class="fn">compare</span>(self, other) <span class="ty">int</span>
}</code></pre>

        <p>Implement traits for your types:</p>

        <pre><code><span class="ty">Person</span> <span class="kw">::</span> <span class="kw">impl</span> <span class="ty">Stringer</span> {
    <span class="fn">to_string</span>(self) <span class="ty">str</span> {
        <span class="kw">return</span> <span class="st">"{self.name} ({self.age})"</span>
    }
}</code></pre>

        <h2>Optional Types</h2>

        <p>Use <code>?</code> suffix to mark a type as optional:</p>

        <pre><code>maybe_name := <span class="kw">none</span> <span class="kw">as</span> <span class="ty">str?</span>
actual_name := <span class="st">"Alice"</span></code></pre>

        <h3>The <code>or</code> operator</h3>

        <p>Handle optionals cleanly with <code>or</code>:</p>

        <pre><code><span class="cm">// Provide a default value</span>
name := maybe_name <span class="kw">or</span> <span class="st">"Unknown"</span>

<span class="cm">// Return early if none</span>
name := maybe_name <span class="kw">or return</span>

<span class="cm">// Return a specific value if none</span>
name := maybe_name <span class="kw">or return</span> <span class="st">"default"</span></code></pre>

        <h3>Truthiness</h3>

        <p>Optional values are truthy when present:</p>

        <pre><code><span class="kw">if</span> person.email {
    <span class="fn">send_email</span>(person.email)
}</code></pre>

        <h2>Error Handling</h2>

        <p>Define error types:</p>

        <pre><code><span class="ty">FileNotFound</span> <span class="kw">::</span> <span class="kw">error</span> {
    path <span class="ty">str</span>
}

<span class="ty">ParseError</span> <span class="kw">::</span> <span class="kw">error</span> {
    line    <span class="ty">int</span>
    message <span class="ty">str</span>
}</code></pre>

        <p>Functions can return a value or an error:</p>

        <pre><code><span class="kw">fn</span> <span class="fn">read_config</span>(<span class="ty">str</span> path) <span class="ty">Config</span> <span class="kw">or</span> <span class="ty">Error</span> {
    contents := <span class="fn">read_file</span>(path) <span class="kw">or error</span> <span class="ty">FileNotFound</span> { path: path }
    cfg := <span class="fn">parse</span>(contents) <span class="kw">or error</span> <span class="ty">ParseError</span> { line: <span class="nu">1</span>, message: <span class="st">"invalid"</span> }
    <span class="kw">return</span> cfg
}</code></pre>

        <p>Handle errors with <code>or</code>:</p>

        <pre><code>cfg := <span class="fn">read_config</span>(<span class="st">"app.conf"</span>) <span class="kw">or error</span> <span class="ty">StartupError</span> {}
cfg := <span class="fn">read_config</span>(<span class="st">"app.conf"</span>) <span class="kw">or return</span></code></pre>

        <h2>Arrays</h2>

        <p>Arrays use the <code>[]</code> suffix:</p>

        <pre><code>numbers := [<span class="nu">1</span>, <span class="nu">2</span>, <span class="nu">3</span>, <span class="nu">4</span>, <span class="nu">5</span>]
names := [<span class="st">"Alice"</span>, <span class="st">"Bob"</span>, <span class="st">"Charlie"</span>]
<span class="ty">Person[]</span> people = []  <span class="cm">// empty arrays need explicit type</span></code></pre>

        <p>Access elements by index:</p>

        <pre><code>first := numbers[<span class="nu">0</span>]
name := names[<span class="nu">1</span>]</code></pre>

        <h3>Array Methods</h3>

        <pre><code>items := [<span class="nu">1</span>, <span class="nu">2</span>, <span class="nu">3</span>]

<span class="cm">// Get length</span>
count := items.<span class="fn">len</span>()  <span class="cm">// 3</span>

<span class="cm">// Append an element</span>
items.<span class="fn">push</span>(<span class="nu">4</span>)  <span class="cm">// items is now [1, 2, 3, 4]</span></code></pre>

        <h2>Maps</h2>

        <p>Maps are key-value collections using <code>Map&lt;K, V&gt;</code> syntax:</p>

        <pre><code>counts := <span class="ty">Map</span>&lt;<span class="ty">str</span>, <span class="ty">int</span>&gt;{}

<span class="cm">// Set values using index syntax</span>
counts[<span class="st">"foo"</span>] = <span class="nu">1</span>
counts[<span class="st">"bar"</span>] = <span class="nu">2</span>

<span class="cm">// Get values</span>
foo_count := counts[<span class="st">"foo"</span>]</code></pre>

        <h3>Map Methods</h3>

        <pre><code><span class="cm">// Check if key exists</span>
<span class="kw">if</span> counts.<span class="fn">has</span>(<span class="st">"foo"</span>) {
    <span class="fn">print</span>(<span class="st">"found foo"</span>)
}

<span class="cm">// Get number of entries</span>
size := counts.<span class="fn">len</span>()

<span class="cm">// Delete a key</span>
counts.<span class="fn">delete</span>(<span class="st">"bar"</span>)</code></pre>

        <p>Maps currently support string keys only. Integer keys will be added in a future version.</p>

        <h2>Control Flow</h2>

        <h3>If/Else</h3>

        <pre><code><span class="kw">if</span> x > <span class="nu">10</span> {
    <span class="fn">print</span>(<span class="st">"big"</span>)
} <span class="kw">else if</span> x > <span class="nu">5</span> {
    <span class="fn">print</span>(<span class="st">"medium"</span>)
} <span class="kw">else</span> {
    <span class="fn">print</span>(<span class="st">"small"</span>)
}</code></pre>

        <h3>For Loops</h3>

        <p>Iterate over collections:</p>

        <pre><code>nums := [<span class="nu">1</span>, <span class="nu">2</span>, <span class="nu">3</span>]

<span class="kw">for</span> n <span class="kw">in</span> nums {
    <span class="fn">print</span>(n)
}

<span class="kw">for</span> person <span class="kw">in</span> people {
    <span class="fn">print</span>(person.<span class="fn">greet</span>())
}</code></pre>

        <h3>While Loops</h3>

        <p>Loop while a condition is true:</p>

        <pre><code>count := <span class="nu">0</span>
<span class="kw">while</span> count < <span class="nu">10</span> {
    <span class="fn">print</span>(count)
    count += <span class="nu">1</span>
}</code></pre>

        <h3>Break and Continue</h3>

        <p>Use <code>break</code> to exit a loop early:</p>

        <pre><code><span class="kw">for</span> n <span class="kw">in</span> nums {
    <span class="kw">if</span> n == target {
        <span class="kw">break</span>
    }
}</code></pre>

        <p>Use <code>continue</code> to skip to the next iteration:</p>

        <pre><code><span class="kw">for</span> n <span class="kw">in</span> nums {
    <span class="kw">if</span> n < <span class="nu">0</span> {
        <span class="kw">continue</span>
    }
    <span class="fn">process</span>(n)
}</code></pre>

        <h3>Match Expressions</h3>

        <p>Match is an expression that returns a value. Use it with literals:</p>

        <pre><code>msg := <span class="kw">match</span> status {
    <span class="nu">200</span> -> <span class="st">"OK"</span>,
    <span class="nu">404</span> -> <span class="st">"Not found"</span>,
    <span class="nu">500</span> -> <span class="st">"Server error"</span>,
    _ -> <span class="st">"Unknown"</span>
}</code></pre>

        <p>Match on variants with destructuring:</p>

        <pre><code><span class="ty">Option</span> <span class="kw">::</span> <span class="kw">variant</span> {
    <span class="ty">Some</span> { value <span class="ty">int</span> }
    <span class="ty">None</span>
}

<span class="kw">fn</span> <span class="fn">unwrap_or</span>(<span class="ty">Option</span> opt, <span class="ty">int</span> default) <span class="ty">int</span> {
    <span class="kw">return match</span> opt {
        <span class="ty">Option</span>.<span class="ty">Some</span> { value: v } -> v,
        <span class="ty">Option</span>.<span class="ty">None</span> -> default
    }
}</code></pre>

        <p>Use <code>using</code> to avoid repeating the variant name:</p>

        <pre><code><span class="kw">fn</span> <span class="fn">unwrap_or</span>(<span class="ty">Option</span> opt, <span class="ty">int</span> default) <span class="ty">int</span> {
    <span class="kw">return match</span> opt <span class="kw">using</span> <span class="ty">Option</span> {
        <span class="ty">Some</span> { value: v } -> v,
        <span class="ty">None</span> -> default
    }
}</code></pre>

        <p>Match on tuples for comparing multiple values:</p>

        <pre><code><span class="kw">fn</span> <span class="fn">compare</span>(<span class="ty">int</span> a, <span class="ty">int</span> b) <span class="ty">str</span> {
    <span class="kw">return match</span> (a, b) {
        (<span class="nu">0</span>, <span class="nu">0</span>) -> <span class="st">"both zero"</span>,
        (<span class="nu">0</span>, _) -> <span class="st">"a is zero"</span>,
        (_, <span class="nu">0</span>) -> <span class="st">"b is zero"</span>,
        _ -> <span class="st">"neither zero"</span>
    }
}</code></pre>

        <h3>Logical Operators</h3>

        <p>Use <code>&&</code>, <code>||</code>, and <code>!</code>:</p>

        <pre><code><span class="kw">if</span> x > <span class="nu">0</span> && y > <span class="nu">0</span> {
    <span class="fn">print</span>(<span class="st">"both positive"</span>)
}

<span class="kw">if</span> x == <span class="nu">0</span> || y == <span class="nu">0</span> {
    <span class="fn">print</span>(<span class="st">"at least one zero"</span>)
}

<span class="kw">if</span> !done {
    <span class="fn">print</span>(<span class="st">"still working"</span>)
}</code></pre>

        <h3>Membership Operator</h3>

        <p>Use <code>in</code> to check if a value is in an array:</p>

        <pre><code><span class="kw">if</span> name <span class="kw">in</span> [<span class="st">"fn"</span>, <span class="st">"if"</span>, <span class="st">"else"</span>, <span class="st">"return"</span>] {
    <span class="fn">print</span>(<span class="st">"is a keyword"</span>)
}

<span class="kw">if</span> x <span class="kw">in</span> [<span class="nu">1</span>, <span class="nu">3</span>, <span class="nu">5</span>, <span class="nu">7</span>, <span class="nu">9</span>] {
    <span class="fn">print</span>(<span class="st">"x is odd and small"</span>)
}</code></pre>

        <h2>Concurrency</h2>

        <h3>Goroutines</h3>

        <p>Launch lightweight threads with <code>go</code>:</p>

        <pre><code><span class="kw">fn</span> <span class="fn">do_work</span>() {
    <span class="cm">// expensive computation</span>
}

<span class="kw">fn</span> <span class="fn">main</span> {
    <span class="kw">go</span> <span class="fn">do_work</span>()
    <span class="kw">go</span> <span class="fn">do_work</span>()
    <span class="cm">// both run concurrently</span>
}</code></pre>

        <h3>Channels</h3>

        <p>Communicate between goroutines with channels:</p>

        <pre><code><span class="kw">fn</span> <span class="fn">producer</span>(<span class="ty">chan int</span> out) {
    out.<span class="fn">send</span>(<span class="nu">42</span>)
}

<span class="kw">fn</span> <span class="fn">main</span> {
    results := <span class="fn">chan</span>() <span class="kw">as</span> <span class="ty">chan int</span>

    <span class="kw">go</span> <span class="fn">producer</span>(results)

    value := results.<span class="fn">recv</span>()  <span class="cm">// blocking receive</span>
    <span class="fn">print</span>(value)  <span class="cm">// 42</span>
}</code></pre>

        <p>Non-blocking receive with fallback:</p>

        <pre><code>value := results.<span class="fn">recv</span>() <span class="kw">or wait</span>(<span class="nu">100</span>)</code></pre>

        <h2>String Interpolation</h2>

        <p>Strings interpolate expressions by default:</p>

        <pre><code>name := <span class="st">"Alice"</span>
age := <span class="nu">30</span>

<span class="fn">print</span>(<span class="st">"Hello, {name}!"</span>)
<span class="fn">print</span>(<span class="st">"{name} is {age} years old"</span>)
<span class="fn">print</span>(<span class="st">"Next year: {age + 1}"</span>)</code></pre>

        <p>Escape braces with backslash:</p>

        <pre><code><span class="fn">print</span>(<span class="st">"Use \{name\} for interpolation"</span>)</code></pre>

        <h2>String Methods</h2>

        <p>Strings have built-in methods for common operations:</p>

        <h3>Length and Character Access</h3>

        <pre><code>s := <span class="st">"hello"</span>
length := s.<span class="fn">len</span>()      <span class="cm">// 5</span>
ch := s.<span class="fn">at</span>(<span class="nu">0</span>)          <span class="cm">// 'h' (returns char)</span></code></pre>

        <h3>Searching</h3>

        <pre><code>s := <span class="st">"hello world"</span>

has := s.<span class="fn">contains</span>(<span class="st">"world"</span>)     <span class="cm">// true</span>
pos := s.<span class="fn">find</span>(<span class="st">"world"</span>)          <span class="cm">// 6 (position, or -1 if not found)</span>

starts := s.<span class="fn">starts_with</span>(<span class="st">"hello"</span>)  <span class="cm">// true</span>
ends := s.<span class="fn">ends_with</span>(<span class="st">"world"</span>)      <span class="cm">// true</span></code></pre>

        <h3>Slicing and Splitting</h3>

        <pre><code>s := <span class="st">"hello world"</span>
sub := s.<span class="fn">slice</span>(<span class="nu">0</span>, <span class="nu">5</span>)    <span class="cm">// "hello"</span>
sub2 := s.<span class="fn">slice</span>(<span class="nu">6</span>, <span class="nu">11</span>)  <span class="cm">// "world"</span>

csv := <span class="st">"a,b,c"</span>
parts := csv.<span class="fn">split</span>(<span class="st">","</span>)  <span class="cm">// ["a", "b", "c"]</span></code></pre>

        <h3>Transformation</h3>

        <pre><code>s := <span class="st">"  Hello World  "</span>

trimmed := s.<span class="fn">trim</span>()           <span class="cm">// "Hello World"</span>
upper := s.<span class="fn">to_upper</span>()         <span class="cm">// "  HELLO WORLD  "</span>
lower := s.<span class="fn">to_lower</span>()         <span class="cm">// "  hello world  "</span>
replaced := s.<span class="fn">replace</span>(<span class="st">"World"</span>, <span class="st">"Shotgun"</span>)  <span class="cm">// "  Hello Shotgun  "</span></code></pre>

        <h2>File I/O</h2>

        <p>Read and write files with built-in functions:</p>

        <pre><code><span class="cm">// Read entire file contents</span>
content := <span class="fn">read_file</span>(<span class="st">"input.txt"</span>)

<span class="cm">// Write to a file</span>
<span class="fn">write_file</span>(<span class="st">"output.txt"</span>, <span class="st">"Hello, World!"</span>)</code></pre>

        <h2>Operators</h2>

        <h3>Arithmetic</h3>

        <pre><code>a + b    <span class="cm">// addition</span>
a - b    <span class="cm">// subtraction</span>
a * b    <span class="cm">// multiplication</span>
a / b    <span class="cm">// division</span>
a % b    <span class="cm">// modulo</span></code></pre>

        <h3>Comparison</h3>

        <pre><code>x == y   <span class="cm">// equal</span>
x != y   <span class="cm">// not equal</span>
x < y    <span class="cm">// less than</span>
x > y    <span class="cm">// greater than</span>
x <= y   <span class="cm">// less or equal</span>
x >= y   <span class="cm">// greater or equal</span></code></pre>

        <h3>Assignment</h3>

        <pre><code>x = <span class="nu">5</span>    <span class="cm">// assign</span>
x += <span class="nu">1</span>   <span class="cm">// add and assign</span>
x -= <span class="nu">1</span>   <span class="cm">// subtract and assign</span>
x *= <span class="nu">2</span>   <span class="cm">// multiply and assign</span>
x /= <span class="nu">2</span>   <span class="cm">// divide and assign</span></code></pre>

        <h2>Packages and Imports</h2>

        <h3>Project Configuration</h3>

        <p>Create a <code>shotgun.toml</code> file in your project root:</p>

        <pre><code>name = "myapp"</code></pre>

        <p>Initialize a new project with:</p>

        <pre><code>shotgun init myapp</code></pre>

        <h3>Package Model</h3>

        <p>shotgun uses a Go-style package system:</p>

        <ul>
            <li><strong>Directory = Package</strong>: Each directory is a package named after the directory</li>
            <li><strong>Files merge</strong>: All <code>.bs</code> files in a directory combine into one namespace</li>
            <li><strong>No imports within package</strong>: Files in the same directory can use each other's symbols directly</li>
        </ul>

        <h3>Example Project Structure</h3>

        <pre><code>myapp/
  shotgun.toml       <span class="cm"># name = "myapp"</span>
  main.bs            <span class="cm"># root package</span>
  helpers.bs         <span class="cm"># merges with main.bs (same directory)</span>
  parser/
    lexer.bs         <span class="cm"># "parser" package</span>
    grammar.bs       <span class="cm"># merges into "parser"</span>
    ast.bs           <span class="cm"># merges into "parser"</span>
  codegen/
    emit.bs          <span class="cm"># "codegen" package</span></code></pre>

        <p>In this structure, <code>main.bs</code> and <code>helpers.bs</code> share a namespace. Functions defined in <code>helpers.bs</code> can be called directly from <code>main.bs</code> without any import.</p>

        <h3>The uses Statement</h3>

        <p>Import other packages with <code>uses:</code> - short form for a few imports:</p>

        <pre><code><span class="kw">uses:</span> parser, codegen</code></pre>

        <p>Or long form with dashes for many imports:</p>

        <pre><code><span class="kw">uses:</span>
  - parser
  - codegen
  - myapp.utils</code></pre>

        <p>Imported symbols are available directly (unqualified access):</p>

        <pre><code><span class="kw">uses:</span> parser

<span class="kw">fn</span> <span class="fn">main</span> {
    <span class="cm">// Call function from parser package directly</span>
    tokens := <span class="fn">tokenize</span>(source)
    ast := <span class="fn">parse</span>(tokens)
}</code></pre>

        <h3>Package Resolution</h3>

        <p>Import paths map to directories:</p>

        <ul>
            <li><code>parser</code> resolves to <code>./parser/</code> (all .bs files)</li>
            <li><code>myapp.utils</code> resolves to <code>./utils/</code></li>
            <li><code>myapp.db.conn</code> resolves to <code>./db/conn/</code></li>
        </ul>

        <h3>Within a Package</h3>

        <p>Files in the same directory share everything - no imports needed:</p>

        <pre><code><span class="cm">// helpers.bs</span>
<span class="kw">fn</span> <span class="fn">helper_add</span>(<span class="ty">int</span> a, <span class="ty">int</span> b) <span class="ty">int</span> {
    <span class="kw">return</span> a + b
}

<span class="ty">Config</span> <span class="kw">::</span> <span class="kw">struct</span> {
    debug <span class="ty">bool</span>
}

<span class="cm">// main.bs (same directory - no import needed)</span>
<span class="kw">fn</span> <span class="fn">main</span> {
    x := <span class="fn">helper_add</span>(<span class="nu">10</span>, <span class="nu">20</span>)  <span class="cm">// defined in helpers.bs</span>
    cfg := <span class="ty">Config</span> { debug: <span class="kw">true</span> }
}</code></pre>

        <h2>Memory Management</h2>

        <p>shotgun uses scope-based arenas. The compiler figures out where to allocate:</p>

        <ul>
            <li><strong>Stack</strong> - local values that don't escape</li>
            <li><strong>Arena</strong> - values that escape, freed when scope ends</li>
        </ul>

        <pre><code><span class="kw">fn</span> <span class="fn">handle_request</span>(<span class="ty">Request</span> req) <span class="ty">Response</span> {
    p := <span class="ty">Person</span> { ... }  <span class="cm">// arena, freed when function returns</span>
    x := <span class="nu">5</span>                    <span class="cm">// stack</span>
    <span class="kw">return</span> <span class="fn">build_response</span>(p)
}</code></pre>

        <p>Mental model: everything dies at end of scope unless you store it somewhere that outlives the scope.</p>

    </div>

    <footer>
        <p>shotgun is open source. <a href="https://github.com/chrishayen/shotgun-lang">GitHub</a> | <a href="mailto:chris@shotgun.dev">chris@shotgun.dev</a></p>
    </footer>
</body>
</html>
